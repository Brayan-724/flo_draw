//!
//! Renders the illustrations used in the guide to `flo_draw`
//!

use flo_canvas::*;
use flo_render_canvas::*;

use futures::prelude::*;
use futures::stream;
use futures::executor;

use png::*;

use std::io::*;
use std::path::*;
use std::fs::*;

/// Size of the badge icons in pixels
const BADGE_SIZE: usize = 64;

///
/// Draws a section badge
///
pub fn section_badge<TDrawFn: FnOnce(&mut Vec<Draw>) -> ()>(filename: &str, background_color: Color, draw: TDrawFn) {
    let (h, s, l, a)        = background_color.to_hsluv_components();

    let (h1, s1, l1, a1)    = (h+2.0, s+5.0, l+15.0, a);
    let (h2, s2, l2, a2)    = (h-2.0, s-5.0, l-15.0, a);

    // The preamble sets up the rendering area (clip mask and background colour)
    let mut preamble    = vec![];

    preamble.clear_canvas(Color::Rgba(0.0, 0.0, 0.0, 0.0));
    preamble.canvas_height(100.0);
    preamble.layer(LayerId(0));

    preamble.new_path();
    preamble.circle(0.0, 0.0, 49.0);
    preamble.clip();

    preamble.new_gradient(GradientId(0), Color::Hsluv(h1, s1, l1, a1));
    preamble.gradient_stop(GradientId(0), 0.5, background_color);
    preamble.gradient_stop(GradientId(0), 1.0, Color::Hsluv(h2, s2, l2, a2));

    preamble.new_path();
    preamble.circle(0.0, 0.0, 50.0);
    preamble.fill_gradient(GradientId(0), -50.0, -30.0, 50.0, 30.0);
    preamble.fill();

    preamble.fill_color(Color::Rgba(0.0, 0.0, 0.0, 1.0));
    preamble.line_width_pixels(1.0);

    // The actual rendering instructions generated by the drawing function
    let mut rendering   = vec![];
    draw(&mut rendering);

    // Render to a bitmap
    let image = executor::block_on(async move {
        let mut context     = initialize_offscreen_rendering().unwrap();
        render_canvas_offscreen(&mut context, BADGE_SIZE, BADGE_SIZE, 1.0, stream::iter(preamble).chain(stream::iter(rendering))).await
    });

    // Save to a png file
    let path            = Path::new(filename);
    let file            = File::create(path).unwrap();
    let ref mut writer  = BufWriter::new(file);

    let mut png_encoder = png::Encoder::new(writer, BADGE_SIZE as _, BADGE_SIZE as _);
    png_encoder.set(png::ColorType::RGBA).set(png::BitDepth::Eight);
    let mut png_writer  = png_encoder.write_header().unwrap();

    png_writer.write_image_data(&image).unwrap();
}

pub fn main() {
    section_badge("test.png", Color::Rgba(0.1, 0.5, 1.0, 0.8), |gc| {
        gc.new_path();
        gc.rect(-20.0, -20.0, 20.0, 20.0);
        gc.fill();
    });
}
